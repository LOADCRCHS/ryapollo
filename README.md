apollo_ruby客户端实现方案

1. 客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。（通过Http Long Polling实现）
2. 客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。
  + 这是一个fallback机制，为了防止推送机制失效导致配置不更新
  + 客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified
  + 定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。
3. 客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中
4. 客户端会把从服务端获取到的配置在本地文件系统缓存一份
5. 在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置
6. 应用程序可以从Apollo客户端获取最新的配置、订阅配置更新通知

基础功能版
----------------

第一步 
  客户端手动拉取服务端的配置
第二步 
  客户端把从服务端获取到的配置在本地文件系统缓存一份
  在遇到服务不可用,或网络不通的时候,依然能从本地恢复配置
第三步
  客户端定时拉取配置,上报本地版本
第四步
  验证客户端的权限(现在是任何用户都能从`configsevise`拉取配置)
  这一步需要修改`configsevise`的代码,开发适用的鉴权系统
第五步
  客户端和服务端保持一个长连接，实时更新配置。
第六步
  客户端容灾


配置获取需求
----------------

应用程序可以从apollo客户端获取最新的配置
应用程序可以从apollo客户端订阅配置更新通知

1. 需要实时修改的配置
2. 需要定时拉取的配置
3. 在服务启动的时候拉取的配置?

各种功能的开关、参数的配置、服务器的地址

1. 静态配置
  
2. 动态配置


问题
----------------

1. 如何实现客户端缓存?避免没获取一次配置就发一次http请求
    + 使用单例模式,设置一个全局的`config`对象,在第一次请求的时候将所有的配置存到内存(Hash对象)中
2. 什么时候更新配置
    + 定时拉取配置,每当有新的配置生成,改变Hash对象的值,是一次改变全部的配置还是只改变发生了改变的配置,肯定是后者,怎么做?
3. 什么时候会发生并发问题
4. 怎么解决并发问题